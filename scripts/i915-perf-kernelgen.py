#!/usr/bin/env python2

# Copyright (C) 2015-2016 Intel Corporation
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# Generates code for metric sets supported by the drm i915-perf driver
# including:
#
# - Static arrays describing the various NOA/Boolean/OA register configs
# - Functions/structs for advertising metrics via sysfs
# - Code that can evaluate which configs are available for the current system
#   based on the RPN availability equations
#


import argparse
import copy
import hashlib
from operator import itemgetter
import re
import sys

import xml.etree.cElementTree as et

import pylibs.codegen as codegen
import pylibs.oa_guid_registry as oa_registry

default_set_blacklist = {}


def underscore(name):
    s = re.sub('MHz', 'Mhz', name)
    s = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', s)
    return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s).lower()


def print_err(*args):
    sys.stderr.write(' '.join(map(str,args)) + '\n')


def brkt(subexp):
    if " " in subexp:
        return "(" + subexp + ")"
    else:
        return subexp

def splice_bitwise_and(args):
    return brkt(args[1]) + " & " + brkt(args[0])

def splice_logical_and(args):
    return brkt(args[1]) + " && " + brkt(args[0])

def splice_ult(args):
    return brkt(args[1]) + " < " + brkt(args[0])

def splice_ugte(args):
    return brkt(args[1]) + " >= " + brkt(args[0])

exp_ops = {}
#                 (n operands, splicer)
exp_ops["AND"]  = (2, splice_bitwise_and)
exp_ops["UGTE"] = (2, splice_ugte)
exp_ops["ULT"]  = (2, splice_ult)
exp_ops["&&"]   = (2, splice_logical_and)


c_syms = {}
c_syms["$SliceMask"] = "INTEL_INFO(dev_priv)->sseu.slice_mask"
c_syms["$SubsliceMask"] = "INTEL_INFO(dev_priv)->sseu.subslice_mask"
c_syms["$SkuRevisionId"] = "dev_priv->drm.pdev->revision"

mnemonic_syms = {}
mnemonic_syms["$SliceMask"] = "slices"
mnemonic_syms["$SubsliceMask"] = "subslices"
mnemonic_syms["$SkuRevisionId"] = "sku"

copyright = """/*
 * Autogenerated file by GPU Top : https://github.com/rib/gputop
 * DO NOT EDIT manually!
 *
 *
 * Copyright (c) 2015 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 */

"""


def splice_rpn_expression(metric_set, expression, symbols):
    tokens = expression.split()
    stack = []

    for token in tokens:
        stack.append(token)
        while stack and stack[-1] in exp_ops:
            op = stack.pop()
            argc, callback = exp_ops[op]
            args = []
            for i in range(0, argc):
                operand = stack.pop()
                if operand[0] == "$":
                    if operand in symbols:
                        operand = symbols[operand]
                    else:
                        raise Exception("Failed to resolve variable " + operand +
                                        " in expression " + expression + " for " + metric_set['set_element'].get('name'));
                args.append(operand)

            subexp = callback(args)

            stack.append(subexp)

    if len(stack) != 1:
        raise Exception("Spurious empty rpn expression for " + metric_set['set_element'].get('name') +
                        ".\nThis is probably due to some unhandled RPN operation, in the expression \"" +
                        expression + "\"")

    return stack.pop()


def output_b_counter_config(metric_set, config):
    c("\nstatic const struct i915_oa_reg b_counter_config_" + metric_set['perf_name_lc'] + "[] = {")

    c.indent(8)

    n_regs = 0
    for reg in config.findall("register"):
        assert reg.get('type') == 'OA'

        addr = int(reg.get('address'), 16)
        addr_str = "0x%x" % addr
        val = int(reg.get('value'), 16)
        val_str = "0x%08x" % val

        c("{ _MMIO(" + addr_str + "), " + val_str + " },")
        n_regs = n_regs + 1

    c.outdent(8)

    c("};")


def output_flex_config(metric_set, config):
    c("\nstatic const struct i915_oa_reg flex_eu_config_" + metric_set['perf_name_lc'] + "[] = {")

    c.indent(8)

    n_regs = 0
    for reg in config.findall("register"):
        assert reg.get('type') == 'FLEX'

        addr = int(reg.get('address'), 16)
        addr_str = "0x%x" % addr
        val = int(reg.get('value'), 16)
        val_str = "0x%08x" % val

        c("{ _MMIO(" + addr_str + "), " + val_str + " },")
        n_regs = n_regs + 1

    c.outdent(8)

    c("};")


def exp_to_symbol(exp):
    exp = exp.replace(' & ', '_')
    exp = exp.replace(' && ', '_and_')
    exp = exp.replace(' >= ', '_gte_')
    exp = exp.replace(' < ', '_lt_')
    exp = exp.replace(' ', '_')
    exp = exp.replace('(', '')
    exp = exp.replace(')', '')
    exp = exp.replace(')', '')

    return exp


def count_config_mux_registers(config):
    n_regs = 0
    for reg in config.findall("register"):
        if reg.get('type') == 'NOA':
            addr = reg.get('address')
            n_regs = n_regs + 1
    return n_regs


def output_mux_configs(metric_set, config_tuples):

    configs.sort(key=itemgetter(0))

    for (priority, config) in config_tuples:
        availability = config.get('availability')

        if availability:
            mnemonic_exp = splice_rpn_expression(metric_set, availability, mnemonic_syms)
            mnemonic_exp = exp_to_symbol(mnemonic_exp)
            infix = "_" + str(priority) + "_" + mnemonic_exp
        else:
            # It wouldn't make sense to have an unconditional config with
            # a higher priority than any other config
            assert config == config_tuples[-1][1]
            infix = ""

        c("\nstatic const struct i915_oa_reg mux_config_" + metric_set['perf_name_lc'] + infix + "[] = {")

        c.indent(8)
        for reg in config.findall("register"):
            assert reg.get('type') == 'NOA'
            addr = int(reg.get('address'), 16)
            addr_str = "0x%x" % addr
            val = int(reg.get('value'), 16)
            val_str = "0x%08x" % val

            c("{ _MMIO(" + addr_str + "), " + val_str + " },")
        c.outdent(8)

        c("};")


def output_mux_config_get_func(metric_set, mux_config_tuples):
    c("\n")
    c("static int")
    fname = "get_" + metric_set['perf_name_lc']  + "_mux_config"
    c(fname + "(struct drm_i915_private *dev_priv,")
    c.indent(len(fname) + 1)
    c("const struct i915_oa_reg **regs,")
    c("int *lens)")
    c.outdent(len(fname) + 1)
    c("{")
    c.indent(8)
    c("int n = 0;")
    c("\n")
    c("BUILD_BUG_ON(ARRAY_SIZE(dev_priv->perf.oa.mux_regs) < %i);" % len(mux_config_tuples))
    c("BUILD_BUG_ON(ARRAY_SIZE(dev_priv->perf.oa.mux_regs_lens) < %i);" % len(mux_config_tuples))
    c("\n")

    seen_conditional_config = 0
    i = 0
    for config_tuple in sorted(mux_config_tuples, key=lambda x: x[0]):
        priority, config = config_tuple

        availability = config.get('availability')
        if availability:
            seen_conditional_config = 1
            code_exp = splice_rpn_expression(metric_set, availability, c_syms)
            mnemonic_exp = splice_rpn_expression(metric_set, availability, mnemonic_syms)
            mnemonic_exp = exp_to_symbol(mnemonic_exp)
            infix = "_" + str(priority) + "_" + mnemonic_exp

            lines = code_exp.split(' && ')
            n_lines = len(lines)
            if n_lines == 1:
                c("if (" + lines[0] + ") {")
            else:
                c("if (" + lines[0] + " &&")
                if i > 0:
                    subexp_indent = 11
                else:
                    subexp_indent = 4
                c.indent(subexp_indent)
                for i in range(1, (n_lines - 1)):
                    print_err(lines[i] + " &&")
                c(lines[(n_lines - 1)] + ") {")
                c.outdent(subexp_indent)
            c.indent(8)

            array_name = "mux_config_" + metric_set['perf_name_lc']  + infix
            c("regs[n] = " + array_name + ";")
            c("lens[n] = ARRAY_SIZE(" + array_name + ");")
            c("n++;")

            c.outdent(8)
            c("}")
        else:
            # Unconditonal MUX config
            #
            # It wouldn't make sense to have an unconditional config with
            # a higher priority than any other config
            assert config == mux_config_tuples[-1][1]

            array_name = "mux_config_" + metric_set['perf_name_lc']
            c("regs[n] = " + array_name + ";")
            c("lens[n] = ARRAY_SIZE(" + array_name + ");")
            c("n++;")

        i = i + 1

    c("\n")
    c("return n;")

    c.outdent(8)
    c("}")


def output_b_and_flex_configs_select(metric_set, b_counter_config, flex_config):
    c("\n")
    c("dev_priv->perf.oa.b_counter_regs =")
    c.indent(8)
    c("b_counter_config_" + metric_set['perf_name_lc']  + ";")
    c.outdent(8)
    c("dev_priv->perf.oa.b_counter_regs_len =")
    c.indent(8)
    c("ARRAY_SIZE(b_counter_config_" + metric_set['perf_name_lc']  + ");")
    c.outdent(8)

    c("\n")
    c("dev_priv->perf.oa.flex_regs =")
    c.indent(8)
    c("flex_eu_config_" + metric_set['perf_name_lc']  + ";")
    c.outdent(8)
    c("dev_priv->perf.oa.flex_regs_len =")
    c.indent(8)
    c("ARRAY_SIZE(flex_eu_config_" + metric_set['perf_name_lc']  + ");")
    c.outdent(8)


def output_sysfs_code(sets):
    for metric_set in sets:
        perf_name = metric_set['perf_name']
        perf_name_lc = metric_set['perf_name_lc']

        c("\n")
        c("static ssize_t")
        c("show_" + perf_name_lc + "_id(struct device *kdev, struct device_attribute *attr, char *buf)")
        c("{")
        c.indent(8)
        c("return sprintf(buf, \"%d\\n\", METRIC_SET_ID_" + perf_name + ");")
        c.outdent(8)
        c("}")

        c("\n")
        c("static struct device_attribute dev_attr_" + perf_name_lc + "_id = {")
        c.indent(8)
        c(".attr = { .name = \"id\", .mode = 0444 },")
        c(".show = show_" + perf_name_lc + "_id,")
        c(".store = NULL,")
        c.outdent(8)
        c("};")

        c("\n")
        c("static struct attribute *attrs_" + perf_name_lc + "[] = {")
        c.indent(8)
        c("&dev_attr_" + perf_name_lc + "_id.attr,")
        c("NULL,")
        c.outdent(8)
        c("};")

        c("\n")
        c("static const struct attribute_group group_" + perf_name_lc + " = {")
        c.indent(8)
        c(".name = \"" + metric_set['guid'] + "\",")
        c(".attrs =  attrs_" + perf_name_lc + ",")
        c.outdent(8)
        c("};")


    h("extern int i915_perf_register_sysfs_" + chipset.lower() + "(struct drm_i915_private *dev_priv);")
    h("\n")

    c("\n")
    c("int")
    c("i915_perf_register_sysfs_" + chipset.lower() + "(struct drm_i915_private *dev_priv)")
    c("{")
    c.indent(8)
    c("const struct i915_oa_reg *mux_regs[ARRAY_SIZE(dev_priv->perf.oa.mux_regs)];")
    c("int mux_lens[ARRAY_SIZE(dev_priv->perf.oa.mux_regs_lens)];")
    c("int ret = 0;")
    c("\n")

    for metric_set in sets:
        c("if (get_" + metric_set['perf_name_lc'] + "_mux_config(dev_priv, mux_regs, mux_lens)) {")
        c.indent(8)
        c("ret = sysfs_create_group(dev_priv->perf.metrics_kobj, &group_" + metric_set['perf_name_lc'] + ");")
        c("if (ret)")
        c.indent(8)
        c("goto error_" + metric_set['perf_name_lc'] + ";")
        c.outdent(8)
        c.outdent(8)
        c("}")

    c("\n")
    c("return 0;")
    c("\n")

    c.outdent(8)
    prev_set = None
    rev_sets = sets[:]
    rev_sets.reverse()
    for i in range(0, len(rev_sets) - 1):
        set0 = rev_sets[i]
        set1 = rev_sets[i + 1]
        c("error_" + set0['perf_name_lc'] + ":")
        c.indent(8)
        c("if (get_" + set1['perf_name_lc'] + "_mux_config(dev_priv, mux_regs, mux_lens))")
        c.indent(8)
        c("sysfs_remove_group(dev_priv->perf.metrics_kobj, &group_" + set1['perf_name_lc'] + ");")
        c.outdent(8)
        c.outdent(8)
    c("error_" + rev_sets[-1]['perf_name_lc'] + ":")
    c.indent(8)
    c("return ret;")
    c.outdent(8)

    c("}")

    h("extern void i915_perf_unregister_sysfs_" + chipset.lower() + "(struct drm_i915_private *dev_priv);")
    h("\n")

    c("\n")
    c("void")
    c("i915_perf_unregister_sysfs_" + chipset.lower() + "(struct drm_i915_private *dev_priv)")
    c("{")
    c.indent(8)
    c("const struct i915_oa_reg *mux_regs[ARRAY_SIZE(dev_priv->perf.oa.mux_regs)];")
    c("int mux_lens[ARRAY_SIZE(dev_priv->perf.oa.mux_regs_lens)];")
    c("\n")
    for metric_set in sets:
        c("if (get_" + metric_set['perf_name_lc'] + "_mux_config(dev_priv, mux_regs, mux_lens))")
        c.indent(8)
        c("sysfs_remove_group(dev_priv->perf.metrics_kobj, &group_" + metric_set['perf_name_lc'] + ");")
        c.outdent(8)
    c.outdent(8)
    c("}")


parser = argparse.ArgumentParser()
parser.add_argument("xml", nargs="+", help="XML description of metrics")
parser.add_argument("--guids", required=True, help="Metric set GUID registry")
parser.add_argument("--chipset", required=True, help="Chipset being output for")
parser.add_argument("--c-out", required=True, help="Filename for generated C code")
parser.add_argument("--h-out", required=True, help="Filename for generated header")
parser.add_argument("--sysfs", action="store_true", help="Output code for sysfs")
parser.add_argument("--whitelist", help="Override default metric set whitelist")
parser.add_argument("--no-whitelist", action="store_true", help="Bypass default metric set whitelist")
parser.add_argument("--blacklist", help="Don't generate anything for given metric sets")

args = parser.parse_args()

guids = {}

chipset = args.chipset.upper()

guids_xml = et.parse(args.guids)
for guid in guids_xml.findall(".//guid"):
    if 'config_hash' in guid.attrib:
        hashing_key = oa_registry.Registry.chipset_derive_hash(guid.get('chipset'), guid.get('config_hash'))
        guids[hashing_key] = guid.get('id')

# Note: either filename argument may == None
h = codegen.Codegen(args.h_out);
h.use_tabs = True
c = codegen.Codegen(args.c_out);
c.use_tabs = True

h(copyright)
h("#ifndef __I915_OA_" + chipset + "_H__\n")
h("#define __I915_OA_" + chipset + "_H__\n\n")

c(copyright)

if args.sysfs:
    c("#include <linux/sysfs.h>")
    c("\n")

c("#include \"i915_drv.h\"\n")
c("#include \"i915_oa_" + args.chipset + ".h\"\n")

sets = []

for arg in args.xml:
    xml = et.parse(arg)

    for set_element in xml.findall(".//set"):

        assert set_element.get('chipset') == chipset

        set_name = set_element.get('symbol_name')

        # Exception on Haswell, which doesn't have a test config.
        if chipset == 'HSW':
          if set_name != 'RenderBasic':
              continue
        elif set_name != 'TestOa':
            continue

        if args.whitelist:
            set_whitelist = args.whitelist.split()
            if set_name not in set_whitelist:
                continue

        if args.blacklist:
            set_blacklist = args.blacklist.split()
        else:
            set_blacklist = default_set_blacklist
        if set_name in set_blacklist:
            continue

        configs = set_element.findall("register_config")
        if len(configs) == 0:
            print_err("WARNING: Missing register configuration for set \"" + set_element.get('name') + "\" (SKIPPING)")
            continue

        hw_config_hash = oa_registry.Registry.hw_config_hash(set_element)
        hashing_key = oa_registry.Registry.chipset_derive_hash(chipset.lower(), hw_config_hash)
        if hashing_key not in guids:
            print_err("WARNING: No GUID found for metric set " + chipset + ", " + set_element.get('name') + " (expected key = " + hashing_key + ") (SKIPPING)")
            continue

        perf_name_lc = underscore(set_name)
        perf_name = perf_name_lc.upper()

        metric_set = {
                'name': set_name,
                'set_element': set_element,
                'chipset_lc': chipset.lower(),
                'perf_name_lc': perf_name_lc,
                'perf_name': perf_name,
                'guid': guids[hashing_key],
                'configs': configs
              }
        sets.append(metric_set)

    c("\nenum metric_set_id {")
    c.indent(8)
    c("METRIC_SET_ID_" + sets[0]['perf_name'] + " = 1,");
    for metric_set in sets[1:]:
        c("METRIC_SET_ID_" + metric_set['perf_name'] + ",");

    c.outdent(8)
    c("};")

    h("extern int i915_oa_n_builtin_metric_sets_" + chipset.lower() + ";\n\n")
    c("\nint i915_oa_n_builtin_metric_sets_" + chipset.lower() + " = " + str(len(sets)) + ";\n")

    for metric_set in sets:
        set_name = metric_set['name']
        configs = metric_set['configs']

        mux_configs = []
        b_counter_configs = []
        flex_configs = []
        for config in configs:
            config_type = config.get('type')
            if config_type == "NOA":
                if config.get('priority') != None:
                    priority = int(config.get('priority'))
                else:
                    priority = 0
                mux_configs.append((priority, config))
            elif config_type == "OA":
                b_counter_configs.append(config)
            elif config_type == "FLEX":
                flex_configs.append(config)

        if len(b_counter_configs) == 0:
            empty = et.Element('register_config')
            b_counter_configs.append(empty)
        assert len(b_counter_configs) == 1
        output_b_counter_config(metric_set, b_counter_configs[0])

        if len(flex_configs) == 0:
            empty = et.Element('register_config')
            flex_configs.append(empty)
        assert len(flex_configs) == 1
        output_flex_config(metric_set, flex_configs[0])

        assert len(mux_configs) >= 1
        output_mux_configs(metric_set, mux_configs)

        output_mux_config_get_func(metric_set, mux_configs)


h("extern int i915_oa_select_metric_set_" + chipset.lower() + "(struct drm_i915_private *dev_priv);")
h("\n")

c("\n")
c("int i915_oa_select_metric_set_" + chipset.lower() + "(struct drm_i915_private *dev_priv)")
c("{")
c.indent(8)

c("dev_priv->perf.oa.n_mux_configs = 0;")
c("dev_priv->perf.oa.b_counter_regs = NULL;")
c("dev_priv->perf.oa.b_counter_regs_len = 0;")
if chipset != "HSW":
    c("dev_priv->perf.oa.flex_regs = NULL;")
    c("dev_priv->perf.oa.flex_regs_len = 0;")
c("\n")

c("switch (dev_priv->perf.oa.metrics_set) {")

for metric_set in sets:
    perf_name = metric_set['perf_name']
    perf_name_lc = metric_set['perf_name_lc']

    c("case METRIC_SET_ID_" + perf_name + ":")
    c.indent(8)
    c("dev_priv->perf.oa.n_mux_configs =")
    c.indent(8)
    fname = "get_" + perf_name_lc + "_mux_config"
    c(fname + "(dev_priv,")
    c.indent(len(fname) + 1)
    c("dev_priv->perf.oa.mux_regs,")
    c("dev_priv->perf.oa.mux_regs_lens);")
    c.outdent(len(fname) + 1)
    c.outdent(8)
    c("if (dev_priv->perf.oa.n_mux_configs == 0) {")
    c.indent(8)
    c("DRM_DEBUG_DRIVER(\"No suitable MUX config for \\\"" + metric_set['perf_name'] + "\\\" metric set\\n\");")
    c("\n")
    c("/* EINVAL because *_register_sysfs already checked this")
    c(" * and so it wouldn't have been advertised to userspace and")
    c(" * so shouldn't have been requested")
    c(" */")
    c("return -EINVAL;")
    c.outdent(8)
    c("}")

    output_b_and_flex_configs_select(metric_set, b_counter_configs[0], flex_configs[0])
    c("\n")
    c("return 0;")
    c.outdent(8)

c("default:")
c.indent(8)
c("return -ENODEV;")
c.outdent(8)

c("}")
c.outdent(8)
c("}")

if args.sysfs:
    output_sysfs_code(sets)

h("#endif\n")
